# Приложение для тестирования библиотеки 
##### я не придумал название
## Описание
Тестовое приложение демонстрирует работу библиотеки ```mylog```. Приложение получает в параметрах запуска имя файла журнала и уровень важности сообщения по умолчанию, инициализирует библиотеку и принимает ввод от пользователя, форматирует его и передаёт во второй поток для вывода через потокобезопасную очередь. Приложение игнорирует уровни важности ниже установленного по умолчанию.

Документацию к библиотеке можно найти [тут](lib.md#mylog-простая-библиотека-логирования).
## Сборка и запуск
Сборка осуществляется с помощью утилиты make, проверить наличие утилиты можно выполнив
```make --version```. Для компиляции проекта потребуется GCC с поддержкой c++ 17, вы можете проверить это выполнив:
```bash
gcc -v --help 2> /dev/null | grep -iv deprecated | grep "C++" | sed -n '/^ *-std=\([^<][^ ]\+\).*/ {s//\1/p}'
```
Вы можете установить все требуемые компоненты выполнив:
```shell
sudo apt update
sudo apt upgrade
sudo apt install git build-essential
```
1. Клонируйте репозиторий:
```
git clone https://github.com/aidarxa/Infotecs_intern.git
```
2. Перейдите в каталог проекта:
```
cd Infotecs_intern
```
3. Соберите проект:
```
make app
```
Или:
```
make
```
4. Запустите приложение
```
./out/app ИМЯ_ВЫХОДНОГО_ФАЙЛА УРОВЕНЬ_ВАЖНОСТИ_ПО_УМОЛЧАНИЮ
```
> [!TIP]  
> Уровни важности регистронезависимы. Уровни важности ниже установленного по умолчанию игнорируются, нумерация идёт сверху вниз.   
> Приложение поддерживает следующие уровни важности:  
> <span style="color: #B2FBA5"> INFO </span>  = 0  
> <span style="color: #FFC067"> WARNING </span>  = 1  
> <span style="color: #fe6761"> ERROR </span>  = 2
## Использование
Псоле запуска приложение ожидает ввода от пользователя в формате:
``` 
<level> <message>
```
Пример:
```
./out/app test.log info
```
```
info произошло событие
WARNING предупреждение
Error Произошла ошибка
Сообщение с уровнем важности по умолчанию
```
Вывод будет таким:
```
[16.02.2025 18:43:12] INFO: произошло событие
[16.02.2025 18:43:12] WARNING: предупреждение
[16.02.2025 18:43:13] ERROR: Произошла ошибка
[16.02.2025 18:52:02] INFO: Сообщение с уровнем важности по умолчанию
```
Или:
```
./out/app test.log Error
```
```
info произошло событие
WARNING предупреждение
Error Произошла ошибка
Сообщение с уровнем важности по умолчанию
```
Вывод будет таким:
```
[16.02.2025 18:52:53] ERROR: Произошла ошибка
[16.02.2025 18:52:54] ERROR: Сообщение с уровнем важности по умолчанию
```

> [!TIP]  
> Выйити из приложения можно введя ```quit```

## Компоненты
### Application.cpp
Application.cpp – главный файл определяющий логику приложения.
Приложение использует два потока: основной, который является производителем (**producer**) задач записи в файл и вспомогательный, являющийся потребителем (**consumer**).

При запуске приложение получает данные об имени файла журнала и уровне важности по умолчанию, производит проверки ввода.
```cpp
int main(int argc, char* argv[]){
    if(argc != 3){
        std::cout << "Неверное количество аргументов\n";
        return -1;
    }
    std::string str = argv[2];
    if(!mylog::util::stringToLogLevel(str)){
        std::cout << "Строка уровня важности не была распознана\n";
        return -1;
    }
}
```
Инициализирует библиотеку [```mylog```](lib.md#mylog-простая-библиотека-логирования) и запускает поток-потребитель.
```cpp
ThreadSafeQueue<std::function<void()>> queue;

void run(){
    while (true) {
        auto task = queue.wait_and_pop();
        if(!task){
            break;
        }
        try{
            (*task)();
        }catch(const mylog::logger_exception& e){
            std::cerr << e.what();
        }
    }
}

int main(int argc, char* argv[]){
    ...
    mylog::FileOutput out{argv[1]};
    mylog::Logger logger{out,*mylog::util::stringToLogLevel(str)};
    std::thread t(run);
    ...
}
```

Запускает цикл чтения команд пользователя и составления задач.
```cpp
...
while (true)
{
    // Слушаем пользователя
    std::string input, inputLevel;
    getline(std::cin,input);
    if(input == "quit") break;
    // Ищем первый пробел и запоминаем уровень доступа
    auto pos = input.find_first_of(" ");
    inputLevel = input.substr(0,pos);
    //Проверяем задан ли уровень доступа, если да - пишем с ним, иначе передаем все сообщение целиком
    if(auto level = mylog::util::stringToLogLevel(inputLevel)) {
        queue.push(
            [message = input.substr(pos+1,input.length()),level = *level,logger]
            ()mutable
            {logger.writeLog(message,level);}
        );
    }
    else{
        queue.push(
            [message = input,logger]
            ()mutable
            {logger.writeLog(message);}
        );
    }
}
...
```
Завершает работу.
```cpp
...
queue.shutdown();
t.join();
...
```
### Обработка ошибок
При ошибке записи в журнал выбрасывается исключение ```mylog::logger_exception```, которое обрабатывается в ```run()```, с надеждой на то, что вот в следующий раз то все обязательно получится.
```cpp
try{
    (*task)();
}catch(const mylog::logger_exception& e){
    std::cerr << e.what();
}
```
## Очистка
Выполните очистку вызвав одну из целей:
```make
make clean  # Удаляет временные файлы в папке build
make clean_all  # Удаляет все скомпилированные файлы (очищает папки buil и out)
```

## Дополнительно: ThreadSafeQueue.h
Класс потокобезопасной очереди ~~ну почти~~
```cpp
template <class T>
class ThreadSafeQueue final
```
| Функция  | Описание |
| --- | --- |
| `push` | **Добавляет** элемент в конец очереди.  |
| `try_pop`  | Удаляет элемент из начала очереди и возвращает `std::optional<T>` если объект есть или `std::nullopt`, если очередь пуста.|
| `wait_and_pop`  | Ожидает, а после удаляет элемент из начала очереди и возвращает `std::optional<T>` если объект есть или `std::nullopt`, если очередь пуста.|
| `empty` | ***НЕБЕЗОПАСНО*** Создает моментальный снимок состояния очереди.  |
| `emplace` | **Создает** элемент в конце очереди.  |
| `shutdown` | Завершает работу очереди. Уведомляет все ожидающие потоки.  |

### push()
***Добавляет*** элемент в конец очереди. 
#### Синтаксис
```cpp
void push(const T& object);
```
#### Параметры
```const T& object```

Объект который будет добавлен в конец очереди.
#### Возвращаемое значение
Нет
### try_pop()
Пытается **получить** объект из начала очереди.
#### Синтаксис
```cpp
std::optional<T> try_pop();
```
#### Параметры
Нет
#### Возвращаемое значение
```std::optional<T>```

Объект типа T, если очередь не пуста, иначе ```std::nullop```.
> [!TIP]  
> Вы можете проверить существует ли объект выполнив ```if (optional) {...}```
> 
> Для доступа к объекту используйте ```operator*()``` или ```value()```.
### wait_and_pop()
**Ожидает**, пока в очередь не будет добавлен объект, а после пытается **получить** объект из начала очереди.
#### Синтаксис
```cpp
std::optional<T> wait_and_pop();
```
#### Параметры
Нет
#### Возвращаемое значение
```std::optional<T>```

Объект типа T, если очередь не пуста, иначе ```std::nullop```.
> [!TIP]  
> Вы можете проверить существует ли объект выполнив ```if (optional) {...}```
> 
> Для доступа к объекту используйте ```operator*()``` или ```value()```.

#### Примечание
В отличие от ```try_pop()``` проверяет, есть ли элементы в очереди и если нет, уходит в ожидание.

> [!IMPORTANT]  
> Если вы используете ```try_pop()``` всегда закрывайте очередь с помощью [```shutdown()```](#shutdown), иначе потоки могут остаться спать навсегда.
### empty()
Проверяет, пуста ли очередь.
> [!WARNING]  
> Возвращает ***моментальный снимок*** очереди, состояние очереди может измениться сразу после выхода из ```empty()```
#### Синтаксис
```cpp
bool empty() const;
```
#### Параметры
Нет
#### Возвращаемое значение
```bool```

```true``` если очередь пуста, иначе ```false```
### emplace()
**Создаёт** объект типа ```T``` в конце очереди.
#### Синтаксис
```cpp
template <typename... Args>
void emplace(Args&&... args);
```
#### Параметры
```Args``` параметры необходимые для построения объекта.
#### Возвращаемое значение
Нет
### shutdown()
**Необратимо** переводит внутренний флаг завершения работы очереди в состояние ```true```. 
> [!CAUTION]  
> Поведение очереди при попытке использовании после вызова ```shutdown()``` ***НЕОПРЕДЕЛЕНО***
#### Синтаксис
```cpp
void shutdown();
```
#### Параметры
Нет
#### Возвращаемое значение
Нет